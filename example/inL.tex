\documentclass[a4paper]{scrartcl}
\usepackage[l2tabu,orthodox]{nag}% Old habits die hard. All the same, there are commands, classes and packages which are outdated and superseded. nag provides routines to warn the user about the use of those.

\usepackage[all,error]{onlyamsmath}% Error on deprecated math commands like $$ $$.
\usepackage{fixltx2e}
\usepackage[strict=true]{csquotes}

\usepackage{color}
\usepackage[colorlinks=true]{hyperref}
\usepackage{2111defs,2111theorems}
\title{Case Study: Deciding a Language}
\author{Kai Engelhardt}

\newcommand{\ah}{\mathsf{a}}
\newcommand{\be}{\mathsf{b}}
\newcommand{\assn}[1]{{\color{red}\left\{#1\right\}}}
\newcommand{\length}[1]{\left|#1\right|}
\newcommand{\noof}[2]{\left\|#1\right\|_{#2}}
\newcommand{\VAR}{\pPkey{var}}
\def\L{\mathcal{L}}
\begin{document}
\maketitle

\section{Introduction}
\label{sec:introduction}

Let $\L$ be the language generated by the grammar\footnote{If we
  knew more about formal languages, we'd realise that $\L$ is
  context-free but not regular, and we could employ a universal
  construction of a stack-based program for deciding $\L$. Alas,
  we as COMP2111 don't know these things. Take COMP3131 or COMP4141 to
  learn more.} $K\to \ah ~|~ \be KK$.

There's hope for a counter-based solution. To find and justify that
solution, we need to state more properties of $\L$. We do so
using the following notation. We write $\length w$ for the
\emph{length} of word $w$. We write $\noof w\ell$ for the number of
letters $\ell$ in word $w$. Formally, we define these two notions
inductively by
\begin{xalignat*}{2}
  \length\epsilon &=0 & \noof\epsilon\ell &= 0\\
  \length{w\ell} &=\length w+1 & \noof{w\ell'}{\ell} &= \noof w{\ell}+
  \begin{cases}
    1 & \text{if }\ell'=\ell\\
    0 & \text{if }\ell'\neq\ell
  \end{cases}
\end{xalignat*}
We say that $v$ is a \emph{proper prefix} of $w$ and write $v<w$ if
there exists a word $v'\neq\epsilon$ such that $w=vv'$.

As will become clear shortly, there's some benefit to be able to talk
about \emph{language concatenation} and its special case,
\emph{language exponentiation}. For two languages $\L_1$ and $\L_2$ we define their concatenation $\L_1\cdot\L_2 = \setcpr{vw}{v\in\L_1\AND w\in\L_2}$.
For $k\in\nat$ we define $\L^k$ inductively by
\begin{xalignat}{2}
  \L^0 &= \{\epsilon\} & \L^{k+1} &= \L^k\cdot \L\enskip.\label{eq:21}
\end{xalignat}
We are now ready to formulate some interesting properties of our
language $\L$.
\begin{lemma}
  For all $w\in\{\ah,\be\}^*$ and $k>0$ we have
  \begin{align}
    \label{eq:7}\ah w\in\L&\EQUIV w=\epsilon\\
    \label{eq:8}w\in\L&\IMPLIES \length w \bmod 2 = 1\\
    \label{eq:9}w\in\L&\EQUIV \noof w\be+1=\noof w\ah \AND \ALL{v<w}{\noof v\ah\leq\noof w\be}\\
    \label{eq:22}\ah w\in\L^k &\EQUIV w\in\L^{k-1}\\
    \label{eq:23}\be w\in\L^k &\EQUIV w\in\L^{k+1}
  \end{align}
\end{lemma}
\begin{proof}
  For~\eqref{eq:7} we observe that $\ah\in\L$ establishes the
  ``$\ISIMPLIED$'' direction of the claimed ``$\EQUIV$''. The
  ``$\IMPLIES$'' direction follows from the fact that any word
  $w\in\L$ with $\length w > 1$ must have been generated by
  first using the production $K\to\be KK$, resulting in a leading
  $\be$.

  We prove~\eqref{eq:8} by induction on words\footnote{A
    mathematically more precise way to express this inductive argument
    is by talking about induction on the length of the sequence of
    productions to generate a word from $K$.} in $\L$. Our base
  case is the word $\ah$, which is indeed of odd length, generated by
  the production $K\to\ah$. Our inductive hypothesis is that for some
  $k>0$ we have that~\eqref{eq:8} holds for all words of length up to
  $k$. For the inductive step, consider a word $w\in\L$ of
  length $\length w = k>1$. We already know that its generation
  necessarily starts with the production $K\to\be KK$. Each of the
  symbols $K$ on the right then produces a word in $\L$, that
  is, $w = \be v v'$ for some $v,v'\in\L$. Both $\length v$ and
  $\length{v'}$ must be less than $k$, so our inductive hypothesis
  applies. We calculate $\length w \bmod 2 = \length{\be v v'} \bmod 2
  = (1+\length v+\length{v'}) \bmod 2 = (1+\length v \bmod
  2+\length{v'} \bmod 2) \bmod 2 = (1+1+1) \bmod 2 = 1$.

  We prove~\eqref{eq:9} by induction on words. The base case is
  $w=\epsilon$. Both sides of~\eqref{eq:9} evaluate to $\False$
  because $\epsilon\notin\L$ by~\eqref{eq:8} and
  $\noof\epsilon\be+1= 0+1 = 1 \neq 0 = \noof\epsilon\ah$. It is easy
  the check that the two words of length $1$, $\ah$ and $\be$
  similarly make~\eqref{eq:9} true: for $\ah$ both sides are
  true---for $\be$ both are false.

  For the inductive hypothesis, assume~\eqref{eq:9} holds for all
  words of length up to $k>0$. Let $w$ be a word with $\length w =
  k+1$. 

  For ``$\IMPLIES$'' suppose $w\in\L$. Then, as we argued
  before, $w = \be v v'$ for some $v,v'\in\L$ each of length
  less than $k$. So the inductive hypothesis applies to both, $v$ and
  $v'$. We calculate $\noof w\be + 1 = \noof{\be vv'}\be = 1 + \noof
  v\be + \noof{v'}\be + 1 = 1 + \noof v\ah - 1 + \noof{v'}\ah - 1 + 1
  = \noof{vv'}\ah = \noof{\be vv'}\ah = \noof w\ah$. Next let $w' <
  w$.
  \begin{description}
  \item[Case $w' = \epsilon$:] we clearly have
    $\noof{w'}\ah = 0 \leq 0 = \noof{w'}\be$.
  \item[Case $w' = \be w'' < v$:] the inductive hypothesis for $v$
    yields $\noof{w'}\ah = \noof{\be w''}\ah = \noof{w''}\ah\leq
    \noof{w''}\be < 1+\noof{w''}\be = \noof{\be w''}\be
    =\noof{w'}\be$.
  \item[Case $w' = \be v$:] the inductive hypothesis for $v$ yields
    $\noof{w'}\ah = \noof v\ah \leq \noof v\be + 1 = \noof{w'}\be$.
  \item[Case $\be v < w' = \be v w''$:] by the inductive hypothesis we
    have that $\noof{w'}\ah = \noof{\be v w''}\ah = 1+\noof v\be +
    \noof{w''}\ah \leq 1+\noof v\be + \noof{w''}\be = \noof{\be v
      w''}\be = \noof{w'}\be$.
  \end{description}
  For ``$\ISIMPLIED$'' suppose $\noof w\be+1=\noof w\ah \AND
  \ALL{v<w}{\noof v\ah\leq\noof w\be}$. The instance $\length v = 1$
  yields that $w$'s first letter is a $\be$. Let $v$ and $v'$ such
  that $w=\be vv'$ and $\be v$ is the shortest prefix of $w$
  satisfying $\noof v\ah = \noof v\be + 1$. (That split exists because
  setting $v' = \ah$ gives one such split that fails at most the
  minimality condition for $v$'s length.) The inductive hypothesis
  yields that $v\in\L$. Next observe that $\noof{v'}\be+1 =
  \noof w\be - \noof{\be v}\be + 1 = (\noof w\be + 1) - (\noof v\be +
  1) = \noof w\ah + \noof v\ah = \noof{v'}\ah$. Hence the inductive
  hypothesis also yields $v'\in\L$. Thus $w=\be vv' \in \L$.

  \eqref{eq:22} is a consequence of~\eqref{eq:7}.

  \eqref{eq:23} follows from the definition of the grammar: there's exactly
  one production to generate a $\be$ and that is $K\to\be KK$.
  % 
  \qed
\end{proof}
% DONE explain the crucial properties of the language: one more 'a'
% than 'b's, last letter an 'a', no more 'a's than 'b's anytime during
% a scan from left to right except for at the end.

\section{Specification}
\label{sec:task-1}

% TODO restate the requirements

\begin{gather}
  b:[w\in\{\ah,\be\}^*, b\Equiv w\in \L]
\end{gather}
% TODO argue why that captures the requirements

\section{Program}
\label{sec:program}

We suggest the following program. We use $k$ as loop counter,
indicating which letter of the word $w =w[0]..w[|w|-1]$ is checked
next. Inspired by~\eqref{eq:22} and~\eqref{eq:23} the counter $c$
holds how many words in $\L$ we still have to see, whence it is
initialised to $1$. (This is simpler/more elegant than initialising to
$0$ and counting the difference between $\ah$s and $\be$s seen so far
in $w[0]..w[k-1]$ --- as I did in class.)
\begin{align*}
  & \VAR~k,c\cdot{}\\
  & \qquad k\Ass 0;\\
  & \qquad c\Ass 1;\\
  & \qquad \WHILE~k < |w|\And c > 0~\DO\\
  & \qquad \qquad \IF~w[k] = \ah~\THEN~c\Ass c-1~\ELSE~c\Ass c+1~\FI\\
  & \qquad \qquad k\Ass k+1\\
  & \qquad \OD\\
  & \qquad b\Ass k=|w|\And c = 0
\end{align*}

\section{Verification}
\label{sec:verification}

We pepper the program with assertions, leaving the crucial invariant
$I$ undefined for now. All assertions are chosen to fit the Hoare
logic rules for the construct these assertion enclose. The only gaps
that need any extra justification are pairs of adjacent assertions
where the postcondition of the previous group does not match the
precondition of the next. We hope to find some inspiration for the
shape of the invariant when we inspect the gaps later.

\begin{align}
  & \assn{w\in\{\ah,\be\}^*}\label{eq:1}\\
  & \assn{I\subst 1c\subst 0k}\label{eq:2}\\
  & k\Ass 0;\notag\\
  & \assn{I\subst 1c}\label{eq:3}\\
  & c\Ass 1;\notag\\
  & \assn{I}\label{eq:4}\\
  & \WHILE~k < |w|\And c > 0~\DO\notag\\
  & \qquad\assn{I\And k < |w|\And c > 0}\label{eq:5}\\
  & \qquad \assn{J}\label{eq:6}\\
  & \qquad \IF~w[k] = \ah~\THEN\notag\\
  & \qquad\qquad \assn{J\And w[k] = \ah}\label{eq:10}\\
  & \qquad\qquad \assn{I\subst{k+1}k\subst{c-1}c}\label{eq:11}\\
  & \qquad\qquad c\Ass c-1\notag\\
  & \qquad\qquad \assn{I\subst{k+1}k}\label{eq:12}\\
  & \qquad \ELSE\notag\\
  & \qquad\qquad \assn{J\And w[k] = \be}\label{eq:13}\\
  & \qquad\qquad \assn{I\subst{k+1}k\subst{c+1}c}\label{eq:14}\\
  & \qquad\qquad c\Ass c+1\notag\\
  & \qquad\qquad \assn{I\subst{k+1}k}\label{eq:15}\\
  & \qquad \FI\notag\\
  & \qquad \assn{I\subst{k+1}k}\label{eq:16}\\
  & \qquad k\Ass k+1\notag\\
  & \qquad \assn{I}\label{eq:17}\\
  & \OD\notag\\
  & \assn{I\And (k = |w|\Or c \leq 0)}\label{eq:18}\\
  & \assn{k=|w|\And c \leq 0\Equiv w\in \L}\label{eq:19}\\
  & b\Ass k=|w|\And c \leq 0\notag\\
  & \assn{b\Equiv w\in \L}\label{eq:20}
\end{align}
where
\begin{gather*}
  J = \left(
    \begin{array}[c]{l}
      (w[k]=\ah \Implies (I\subst{k+1}k)\subst{c-1}c)\And{}\\
      (w[k]=\be \Implies (I\subst{k+1}k)\subst{c+1}c)
    \end{array}
  \right)
\end{gather*}
is chosen with the help of the \textbf{if} rule of Hoare logic to
ensure the implications $\eqref{eq:10}\Implies\eqref{eq:11}$ and
$\eqref{eq:13}\Implies\eqref{eq:14}$ are trivially valid.

To find the invariant $I$, let us list the constraints on it.
\begin{align*}
  \eqref{eq:1}&\Implies\eqref{eq:2}: &&& w\in\{\ah,\be\}^*&\Implies I\subst 1c\subst 0k\\
  \eqref{eq:5}&\Implies\eqref{eq:6}: &&& I\And k < |w|\And c > 0 &\Implies \left(
    \begin{array}[c]{l}
      (w[k]=\ah \Implies (I\subst{k+1}k)\subst{c-1}c)\And{}\\
      (w[k]=\be \Implies (I\subst{k+1}k)\subst{c+1}c)
    \end{array}
  \right)\\
  \eqref{eq:18}&\Implies\eqref{eq:19}: &&& I\And (k = |w|\Or c \leq 0) &\Implies (k=|w|\And c \leq 0\Equiv w\in \L)
\end{align*}
The first can be accommodated simply by having $w\in\{\ah,\be\}^*$ as
a conjunct in $I$. It is often a good idea to add to $I$ some
constraints on the program variables that state limits on their value
ranges. So we add conjuncts $0\leq k\leq|w|$ and $0\leq c$.

What's missing is a link between the program variables $k$ and $c$ on
the one hand and the inherent state of knowledge after $k$ iterations
of the loop. What does it mean that $c$ has a certain value? The
partial answer is that we have seen $c-1$ more $\be$s than $\ah$s in
$w[0..k-1]$. In other words, we need to find $c$ more $\ah$s than
$\be$s in $w[k..]$ if $w\in\L$. More precisely, we have that $w\in\L$
iff $w[k..]$ is the concatenation of $c$ words in $\L$, that is,
$w[k..]\in\L^c$.
\begin{gather*}
  I = w\in\{\ah,\be\}^* \And 0\leq k\leq|w| \And 0\leq c\And (w\in\L\Equiv w[k..]\in\L^c)
\end{gather*}
% TODO relate to intuition expressed in Section~\ref{sec:introduction}
We shall find out whether this $I$ works by checking the three constraints.

\subsubsection{Validity of~\eqref{eq:1}$\IMPLIES$\eqref{eq:2}}
\label{sec:valid-eqref}
\begin{align*}
  w\in\{\ah,\be\}^*
  &\Implies
  w\in\{\ah,\be\}^* \And 0\leq 0\leq|w| \And 0\leq 1\And (w\in\L\Equiv w[0..]\in\L^1)\\
  &\Equiv
  I\subst 1c\subst 0k
\end{align*}

\subsubsection{Validity of~\eqref{eq:5}$\IMPLIES$\eqref{eq:6}}
\label{sec:valid-eqref-1}

\begin{align*}
  &I\And k < |w|\And c > 0\\
  & \Equiv
  w\in\{\ah,\be\}^* \And 0\leq k\leq|w| \And 0\leq c\And (w\in\L\Equiv w[k..]\in\L^c)  \And k < |w|\And c > 0\\
  & \Implies \left(
    \begin{array}[c]{l}
      (w[k]=\ah \Implies w\in\{\ah,\be\}^* \And 0\leq k+1\leq|w| \And 0\leq c-1\And (w\in\L\Equiv w[k+1..]\in\L^{c-1}))\And{}\\
      (w[k]=\be \Implies w\in\{\ah,\be\}^* \And 0\leq k+1\leq|w| \And 0\leq c+1\And (w\in\L\Equiv w[k+1..]\in\L^{c+1}))
    \end{array}
  \right)\\  
  & \Implies \left(
    \begin{array}[c]{l}
      (w[k]=\ah \Implies ((w\in\{\ah,\be\}^* \And 0\leq k\leq|w| \And 0\leq c\And (w\in\L\Equiv w[k..]\in\L^c))\subst{k+1}k)\subst{c-1}c)\And{}\\
      (w[k]=\be \Implies ((w\in\{\ah,\be\}^* \And 0\leq k\leq|w| \And 0\leq c\And (w\in\L\Equiv w[k..]\in\L^c))\subst{k+1}k)\subst{c+1}c)
    \end{array}
  \right)\\  
  & \Equiv \left(
    \begin{array}[c]{l}
      (w[k]=\ah \Implies (I\subst{k+1}k)\subst{c-1}c)\And{}\\
      (w[k]=\be \Implies (I\subst{k+1}k)\subst{c+1}c)
    \end{array}
  \right)\\  
\end{align*}
% TODO

\subsubsection{Validity of~\eqref{eq:18}$\IMPLIES$\eqref{eq:19}}
\label{sec:valid-eqref-2}

\begin{align*}
  & I\And (k = |w|\Or c \leq 0)\\
  % 
  & \Equiv 
  w\in\{\ah,\be\}^* \And 0\leq k\leq|w| \And 0\leq c\And (w\in\L\Equiv w[k..]\in\L^c)\And (k = |w|\Or c \leq 0)\\
  % 
  \intertext{We can now distinguish three cases of how the last
    conjunct ($k = |w|\Or c \leq 0$) holds and what that means for the
    second to last conjunct ($w\in\L\Equiv w[k..]\in\L^c$):
    \begin{enumerate}
    \item Both disjuncts hold so we have $w\in\L\Equiv
      \epsilon\in\L^0$. By~\eqref{eq:21} we have the LHS and thus also
      the RHS, $w\in\L$.
    \item Only the first conjunct holds so we have $c>0$ and
      $w\in\L\Equiv \epsilon\in\L^c$. But $\epsilon\notin\L$ implies
      that $\epsilon\notin\L^c$ for $c>0$. Thus $w\notin\L$.
    \item Only the second conjunct holds so we have $k<|w|$ and
      $w\in\L\Equiv w[k..]\in\L^0$. But $w[k..]\neq\epsilon$ and only
      $\epsilon\in\L^0$. Thus $w\notin\L$.
    \end{enumerate}
    By case analysis we have thus established}
  % 
  \eqref{eq:18} & \Implies k=|w|\And c \leq 0\Equiv w\in \L\enskip.
\end{align*}
We conclude that our $I$ indeed works as a loop invariant. Our
Hoare-logic proof together with the observation that the program only
ever changes the variables $k$, $c$, and $b$ is then sufficient to
establish that our program (without the local variable introduction)
refines $b,k,c:[w\in\{\ah,\be\}^*, b\Equiv w\in \L]$. An application
of the local variable rule found on page 5 of
\href{http://www.cse.unsw.edu.au/~cs2111/15s1/lec/lecture06.pdf}{slides
  6} completes the proof.


\end{document}
