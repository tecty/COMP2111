\documentclass[a4paper,12pt,fleqn]{scrartcl}
\usepackage[l2tabu,orthodox]{nag}% Old habits die hard. All the same, there are commands, classes and packages which are outdated and superseded. nag provides routines to warn the user about the use of those.

\usepackage[all,error]{onlyamsmath}% Error on deprecated math commands like $$ $$.
\usepackage[strict=true]{csquotes}

%\usepackage{color}

\usepackage{listings}
\lstset{frame=single,framerule=0pt,language={C},showstringspaces=false,numbers=left,columns=fullflexible}

% COMP2111-specific macros. See
% http://www.cse.unsw.edu.au/~cs2111/18s1/LaTeX/primer.html
\usepackage{2111defs2}
\usepackage[colorlinks=true]{hyperref}

\newcommand{\assn}[1]{{\color{red}\left\{#1\right\}}}
\newcommand{\remark}[1]{{\sffamily\color{blue}{#1}}}

% define some convenience macros specific to this task
\newcommand{\perm}{\mathsf{perm}}
%title variable
\title{Assignment 1}
\author{z5141448\and Ruofei HUANG}


\newcommand{\variant}[3]{(#1:#2\mapsto #3)}
\newcommand{\oldwhatever}[4]{\variant{#1}{#2}{\variant{#1[#2]}{#3}{#4}}}
\newcommand{\whatever}[4]{\variant{#1}{#2\mapsto #3}{#4}}
\newcommand{\ah}{\mathsf{a}}
\newcommand{\be}{\mathsf{b}}
\newcommand{\length}[1]{\left|#1\right|}
\newcommand{\noof}[2]{\left\|#1\right\|_{#2}}
\def\L{\mathcal{L}}
\begin{document}
\maketitle

\section*{Definations}
\subsection*{Two Dimensional Arrays Expression}
To describe variants of two-dimensional arrays we write
$\whatever bkjx$ instead of $\oldwhatever bkjx$. We use this new
notation to state an instance of the array-assignment axiom we saw
already
\begin{gather*}
    \Htri{\phi\subst{\variant bkx}b}{b[k] \Ass x}{\phi}
\end{gather*}
for two-dimensional arrays:
\begin{gather*}
    \Htri{\phi\subst{\whatever{b}{k}{j}{x}}{b}}{b[k][j] \Ass x}{\phi}
\end{gather*}

\subsection*{String Length}
A string $S \in Letter^*$ which is an array of letters\footnote{The letter here is
a legal charater encode with ASCII, UTF-8 or other charater encoding
standard. }.Also, string will be terminate by the null character which is a convention by the C
programming language and we will follow this convention in this proof. We write $\length{S}$ for 
the number of letters in the string. Formally, we define these two nothion inductively by
\begin{gather*}
    \length{S\ell} =\length S+
    \begin{cases}
      1 & \text{if }\ell\neq '\backslash0'\\
      0 & \text{if }\ell= '\backslash0'
    \end{cases}\\
\end{gather*}
Also, by the convention of C we has this definition for $S \in string$.
\begin{gather*}
    S[\length{S}] = '\backslash0' \And \All{0 \leq i < \length{S}}{S[i]\neq '\backslash0'}
\end{gather*}

\subsection*{String Equals}
To describe two string $a,b$ ($a,b \in String $) are equals we write $a=b$ when:
\begin{gather*}
    a = b \iff\length{a} = \length{b} \And \All{j\in 0..\length{a}}{a[j]  = b[j]}
\end{gather*}
Similarly, we write:
\begin{gather*}
    a \neq b \iff \neg (a = b) 
\end{gather*}
% a programe to write whether the string is equal to another string.
\subsection*{Comparing String}
After defining what is string equal, we need a pieces programme in toy language to 
do the dirty work which could compare two strings.
% A programme should be written to compare string

\subsection*{String Assign}
To assign a string to another string array, we will denote as 
\begin{gather*}
    a := b 
\end{gather*}
instead of a long programme of our toy language:
\begin{gather*}
    \assn{a,b\in String}\\
    \assn{I \subst{0}{i} }\\
    i\Ass 0;\\
    \assn{I}\\
    \WHILE~i\leq\length{b}~\DO\\
        \qquad \assn{I \And i\leq \length{b}}\\
        \qquad \assn{I \subst{i+1}i \subst{a:i\mapsto b[i]}{a}}\\
        \qquad a[i] \Ass b[i];\\
        \qquad \assn{I \subst{i+1}i}\\
        \qquad i \Ass i +1;\\
        \qquad \assn{I}\\
    \OD;\\
    \assn{I\And i>\length{b}}\\
    % \assn{I\subst{a:\length{b}\mapsto '\backslash0' }{a} }\\
    % a[\length{b}] = '\backslash0';\\
    \assn{a,b \in String\And a=b }
\end{gather*}
when our invariant is 
\begin{gather*}
    I = a,b\in String \And 0 \leq i \leq (\length{b}+1) \And \All{k \in 0..(i-1)}{ a[k] = b[k]}  
\end{gather*}
Here are the proofs of the implications:

% 
%  Sessions for proofing *strcpy 
% 

\subsubsection*{
    First Implication for String assign:  
    $a,b\in String\Implies I\subst{0}{i}$
}
\begin{align*}
    & a, b \in String  \\
    % 
    \justification[\Implies]{using $\length{b}\in\nat$ and realising that the last conjunct is vacuously true}
    & a,b\in String \And 0 \leq 0 \leq (\length{b}+1)\And \All{k \in 0..(0-1)}{ a[k] = b[k]} \\
    \justification{definition of I and substitution}
    & I\subst{0}{i}
\end{align*}

\subsubsection*{
    Second Implication
    $I \And i\leq\length{b} \Implies I \subst{i+1}i \subst{a:i\mapsto b[i]}{a} $
}

%Here may need some modification
%
We first look at the LHS:
\begin{align*}
    & I \And i \leq \length{b}\\
    \justification{Substitue I }
    & a,b\in String \And 0 \leq i \leq (\length{b}+1) \And \All{k \in 0..(i-1)}{ a[k] = b[k]} \And i \leq \length{b}\\
    \justification{Conjunct $i\leq (\length{b}+1) $ and $i\leq \length{b}$}
    &a,b\in String \And 0 \leq i \leq \length{b} \And \All{k \in 0..(i-1)}{ a[k] = b[k]} 
\end{align*}
We then expand RHS:
\begin{align*}
    & I \subst{i+1}i \subst{a:i\mapsto b[i]}{a}\\
    \justification{substitute $i = i+1$ and $a[i]= b[i]$ by definition}
    & a,b\in String \And 0 \leq i+1 \leq (\length{b}+1) \And \All{k \in 0..((i+1)-1)}{ a[k] = b[k]} \And a[i] \Ass b[i] 
\end{align*}
We then have a clear imply
\begin{align*}
    & a,b\in String \And 0 \leq i \leq \length{b} \And \All{k \in 0..(i-1)}{ a[k] = b[k]}\\
    \justification[\Implies]{$i \leq \length{b} \Implies i+1\leq \length{b}+1$ and $ a[i] \Ass b[i]$  }
    & a,b\in String \And 0 \leq i+1 \leq (\length{b}+1) \And \All{k \in 0..((i+1)-1)}{ a[k] = b[k]} \And a[i] \Ass b[i] 
\end{align*}


% Third implication should change

\subsubsection*{
    Third Implication
    $I\And i>\length{b} \Implies a,b \in String\And a=b  $
}
\begin{align*}
    &I\And i>\length{b}\\
    \justification{substitution of I }
    &a,b\in String \And 0 \leq i \leq (\length{b}+1) \And \All{k \in 0..(i-1)}{ a[k] \Ass b[k]} \And i > \length{b} \\
    \justification{ $i>\length{b}$and $i \leq (\length{b}+1)$ with some calculation}
    & a,b\in String \And \All{k \in 0..\length{b}}{ a[k] \Ass b[k]}\\
    \justification[\Implies]{Definition of two string equal}
    & a,b \in String \And a = b
\end{align*}



\section{Task 1}
Since we have define some manipulation of String, we can see a 
string as a whole. So the input is an array of String. Also ,
the ouput is store in $b$ which is an empty array (type is $String*$ too 
). Hence we can define our precondiction as:
\begin{gather*}
    a,b\in String^*\And\length{a} = n
\end{gather*}
As the post condition as:
\begin{gather*}
    \All {i < n}{a[i] = b[m(a,i)]}
\end{gather*}
Where m is a mapping function define recursively as follow:
\begin{gather*}
    m(a,i) = 
    \begin{cases}
        0         & \text{if } i=0\\
        m(i-1)    & \text{if } a[i] = a[i-1]\\
        m(i-1) +1 & \text{if } a[i] \neq a[i-1]
    \end{cases}
\end{gather*}

\section{Task 2}
We propose the following proof outline to demonstrate the correctness
of our code (in black).
\begin{gather}
    \assn{a,b\in String^*\And\length{a} = n}\\
    \assn{J}\\
    \IF~ \length{a} >0 ~ \THEN\\
    \qquad \assn{J \And \length{a} > 0}\\
    \qquad \assn{I \subst{1}{j} \subst{1}{i} \subst{b:0 \mapsto a[0]}{b}}\\
    \qquad b[0] \Ass a[0];\\
    \qquad \assn{I \subst{1}{j} \subst{1}{i}  }\\
    \qquad i=1;j=1;\\
    \qquad \assn{I}\\
    \ELSE\\ 
    \qquad \assn{J \And \length{a} \leq 0}\\
    \qquad \assn{I\subst{0}{i}\subst{0}{j}}\\
    \qquad i\Ass 0;j\Ass 0;\\
    \qquad \assn{I}\\
    \FI\\
% 
    \assn{I}\\
    \WHILE~i<\length{a}~\DO\\
    \qquad \assn{I \And i < \length{a}}\\
    \qquad \assn{K }\\
    \qquad \IF~a[i] \neq a[i-1]~ \THEN\\
    \qquad \qquad \assn{K \And a[i]\neq a[i-1]}\\
    \qquad \qquad \assn{I \subst{i+1}{i} \subst{j+1}{j} \subst{b:j\mapsto a[i]}{b}}\\
    \qquad \qquad b[j] \Ass a[i];\\
    \qquad \qquad \assn{I \subst{i+1}{i} \subst{j+1}{j} }\\
    \qquad \qquad j \Ass j +1;\\
    \qquad \qquad \assn{I \subst{i+1}{i}}\\
    \qquad \ELSE\\
    \qquad \qquad skip \\
    \qquad \FI\\
    \qquad \assn{I \subst{i+1}{i}}\\
    \qquad i \Ass i +1 \\
    \qquad \assn{I}\\
    \OD\\
% 
    \assn{I \And i \geq \length{a}}\\
    \assn{\All {i < n}{a[i] = b[m(a,i)]}}
\end{gather}
Here are the invariants of this programme
\footnote{The invariant is following the case study in week 8, might not be true for the
 stuff we study for now. But I have to use this tool otherwise I couldn't countinue 
 this proof}:
\begin{gather*}
    I = a,b\in String^*\And\length{a} = n \And 
    0 \leq i \leq \length{a} \And \All{k \in 0..(i-1)}{ a[k] = b[m(a,k)]} \\
    J = 
    \left(\begin{array}[c]{l}
        \length{a}>0 \Implies I \subst{1}{j} \subst{1}{i} \subst{b:0 \mapsto a[0]}{b}\\
        \length{a}\leq 0 \Implies I \subst{0}{j} \subst{0}{i}
    \end{array}\right)\\
    K = 
    \left(\begin{array}[c]{l}
        a[i] \neq a[i-1] \Implies I \subst{i+1}{i} \subst{j+1}{j} \subst{b:j\mapsto a[i]}{b}\\
        a[i] =    a[i-1] \Implies I \subst{i+1}{i}
    \end{array}\right)
\end{gather*}
% work should continue here
\subsection{First Implication: $a,b\in String^*\And\length{a} = n \Implies J$}
\begin{align*}
    &a,b\in String^*\And\length{a} = n\\
    \justification[\Implies]{$n \in \nat$, substitution of $i,j$ }
    &\left(\begin{array}[c]{l}
        \length{a}>0 \Implies a,b\in String^*\And\length{a} = n \And 
        0 \leq 1 \leq \length{a} \And \All{k \in 0..(1-1)}{ a[k] = b[m(a,k)]}\\
    % another part of I 
        \length{a} = 0 \Implies a,b\in String^*\And\length{a} = n \And 
        0 \leq 0 \leq \length{a} \And \All{k \in 0..(0-1)}{ a[k] = b[m(a,k)]}
    \end{array}\right)\\
    \justification[\Implies]{Substitution of I }
    &\left(\begin{array}[c]{l}
        \length{a}>0 \Implies I \subst{1}{j} \subst{1}{i} \subst{b:0 \mapsto a[0]}{b}\\
        \length{a}\leq 0 \Implies I \subst{0}{j} \subst{0}{i}
    \end{array}\right)\\
    \justification{Definition of J} 
    &J
\end{align*}
\subsection{Second Implication: $I \And i < \length{a} \Implies K$}
\begin{align*}
    & I \And i < \length{a} \\
    \justification{Definition of $I$}
    & a,b\in String^*\And\length{a} = n \And 
    0 \leq i \leq \length{a} \And \All{k \in 0..(i-1)}{ a[k] = b[m(a,k)]} \And i < \length{a} \\
    \justification[\Implies]{Substitue $i+1$ and $j+1$ and $K$}
    &\left(\begin{array}[c]{l}
        a[i] \neq a[i-1] \Implies a,b\in String^*\And\length{a} = n \And \\
        0 \leq i+1 \leq \length{a}+1 \And \All{k \in 0..(i)}{ a[k] = b[m(a,k)]} \And i < \length{a}\\
        a[i] =    a[i-1] \Implies a,b\in String^*\And\length{a} = n \And \\
        0 \leq i+1 \leq \length{a}+1 \And \All{k \in 0..(i)}{ a[k] = b[m(a,k)]} \And i < \length{a}
    \end{array}\right)\\
    \justification[\Implies]{Conjunct the $i<\length{a}$}
    &\left(\begin{array}[c]{l}
        a[i] \neq a[i-1] \Implies a,b\in String^*\And\length{a} = n \And \\
        0 \leq i+1 \leq \length{a} \And \All{k \in 0..(i)}{ a[k] = b[m(a,k)]}\\
        a[i] =    a[i-1] \Implies a,b\in String^*\And\length{a} = n \And \\
        0 \leq i+1 \leq \length{a} \And \All{k \in 0..(i)}{ a[k] = b[m(a,k)]}
    \end{array}\right)\\
    \justification{}
    &\left(\begin{array}[c]{l}
        a[i] \neq a[i-1] \Implies I \subst{i+1}{i} \subst{j+1}{j} \subst{b:j\mapsto a[i]}{b}\\
        a[i] =    a[i-1] \Implies I \subst{i+1}{i}
    \end{array}\right)\\
    \justification{}
    &\left(\begin{array}[c]{l}
        a[i] \neq a[i-1] \Implies I \subst{i+1}{i} \subst{j+1}{j} \subst{b:j\mapsto a[i]}{b}\\
        a[i] =    a[i-1] \Implies I \subst{i+1}{i}
    \end{array}\right)\\
    \justification{Definition of K}
    & K
\end{align*}
\section{Task 3}
\section{Task 4}



\end{document}