\documentclass[a4paper,12pt,fleqn]{scrartcl}
\usepackage[l2tabu,orthodox]{nag}% Old habits die hard. All the same, there are commands, classes and packages which are outdated and superseded. nag provides routines to warn the user about the use of those.

\usepackage[all,error]{onlyamsmath}% Error on deprecated math commands like $$ $$.
\usepackage[strict=true]{csquotes}

%\usepackage{color}

\usepackage{listings}
\lstset{frame=single,framerule=0pt,language={C},showstringspaces=false,numbers=left,columns=fullflexible}

% COMP2111-specific macros. See
% http://www.cse.unsw.edu.au/~cs2111/18s1/LaTeX/primer.html
\usepackage{2111defs2}
\usepackage[colorlinks=true]{hyperref}

\newcommand{\assn}[1]{{\color{red}\left\{#1\right\}}}
\newcommand{\remark}[1]{{\sffamily\color{blue}{#1}}}

% define some convenience macros specific to this task
\newcommand{\perm}{\mathsf{perm}}
%title variable
\title{Assignment 1}
\author{z5141448\and Ruofei HUANG}


\newcommand{\variant}[3]{(#1:#2\mapsto #3)}
\newcommand{\oldwhatever}[4]{\variant{#1}{#2}{\variant{#1[#2]}{#3}{#4}}}
\newcommand{\whatever}[4]{\variant{#1}{#2\mapsto #3}{#4}}
\newcommand{\ah}{\mathsf{a}}
\newcommand{\be}{\mathsf{b}}
\newcommand{\length}[1]{\left|#1\right|}
\newcommand{\noof}[2]{\left\|#1\right\|_{#2}}
\def\L{\mathcal{L}}
\begin{document}
\maketitle

\section*{Definations}
\subsection*{Two Dimensional Arrays Expression}
To describe variants of two-dimensional arrays we write
$\whatever bkjx$ instead of $\oldwhatever bkjx$. We use this new
notation to state an instance of the array-assignment axiom we saw
already
\begin{gather*}
    \Htri{\phi\subst{\variant bkx}b}{b[k] \Ass x}{\phi}
\end{gather*}
for two-dimensional arrays:
\begin{gather*}
    \Htri{\phi\subst{\whatever{b}{k}{j}{x}}{b}}{b[k][j] \Ass x}{\phi}
\end{gather*}

\subsection*{String Length}
A string $S \in Letter^*$ which is an array of letters\footnote{The letter here is
a legal charater encode with ASCII, UTF-8 or other charater encoding
standard. }.Also, string will be terminate by the null character which is a convention by the C
programming language and we will follow this convention in this proof. We write $\length{S}$ for 
the number of letters in the string. Formally, we define these two nothion inductively by
\begin{gather*}
    \length{S\ell} =\length S+
    \begin{cases}
      1 & \text{if }\ell\neq '\backslash0'\\
      0 & \text{if }\ell= '\backslash0'
    \end{cases}\\
\end{gather*}
Also, by the convention of C we has this definition for $S \in string$.
\begin{gather*}
    S[\length{S}] = '\backslash0' \And \All{0 \leq i < \length{S}}{S[i]\neq '\backslash0'}
\end{gather*}

\subsection*{String Equals}
To describe two string $a,b$ ($a,b \in String $) are equals we write $a=b$ when:
\begin{gather*}
    a = b \iff\length{a} = \length{b} \And \All{j\in 0..\length{a}}{a[j]  = b[j]}
\end{gather*}
Similarly, we write:
\begin{gather*}
    a \neq b \iff \neg (a = b) 
\end{gather*}
\subsection*{String Assign}
To assign a string to another string array, we will denote as 
\begin{gather*}
    a := b 
\end{gather*}
instead of a long programme of our toy language:
\begin{gather*}
    \assn{a,b\in String}\\
    \assn{I \subst{0}{i} }\\
    i\Ass 0;\\
    \assn{I}\\
    \WHILE~i\leq\length{b}~\DO\\
        \qquad \assn{I \And i\leq \length{b}}\\
        \qquad \assn{I \subst{i+1}i \subst{a:i\mapsto b[i]}{a}}\\
        \qquad a[i] \Ass b[i];\\
        \qquad \assn{I \subst{i+1}i}\\
        \qquad i \Ass i +1;\\
        \qquad \assn{I}\\
    \OD;\\
    \assn{I\And i>\length{b}}\\
    % \assn{I\subst{a:\length{b}\mapsto '\backslash0' }{a} }\\
    % a[\length{b}] = '\backslash0';\\
    \assn{a,b \in String\And a=b }
\end{gather*}
when our invariant is 
\begin{gather*}
    I = a,b\in String \And 0 \leq i \leq (\length{b}+1) \And \All{k \in 0..(i-1)}{ a[k] = b[k]}  
\end{gather*}
Here are the proofs of the implications:

% 
%  Sessions for proofing *strcpy 
% 

\subsubsection*{
    First Implication for String assign:  
    $a,b\in String\Implies I\subst{0}{i}$
}
\begin{align*}
    & a, b \in String  \\
    % 
    \justification[\Implies]{using $\length{b}\in\nat$ and realising that the last conjunct is vacuously true}
    & a,b\in String \And 0 \leq 0 \leq (\length{b}+1)\And \All{k \in 0..(0-1)}{ a[k] = b[k]} \\
    \justification{definition of I and substitution}
    & I\subst{0}{i}
\end{align*}

\subsubsection*{
    Second Implication
    $I \And i\leq\length{b} \Implies I \subst{i+1}i \subst{a:i\mapsto b[i]}{a} $
}

%Here may need some modification
%
We first look at the LHS:
\begin{align*}
    & I \And i \leq \length{b}\\
    \justification{Substitue I }
    & a,b\in String \And 0 \leq i \leq (\length{b}+1) \And \All{k \in 0..(i-1)}{ a[k] = b[k]} \And i \leq \length{b}\\
    \justification{Conjunct $i\leq (\length{b}+1) $ and $i\leq \length{b}$}
    &a,b\in String \And 0 \leq i \leq \length{b} \And \All{k \in 0..(i-1)}{ a[k] = b[k]} 
\end{align*}
We then expand RHS:
\begin{align*}
    & I \subst{i+1}i \subst{a:i\mapsto b[i]}{a}\\
    \justification{substitute $i = i+1$ and $a[i]= b[i]$ by definition}
    & a,b\in String \And 0 \leq i+1 \leq (\length{b}+1) \And \All{k \in 0..((i+1)-1)}{ a[k] = b[k]} \And a[i] \Ass b[i] 
\end{align*}
We then have a clear imply
\begin{align*}
    & a,b\in String \And 0 \leq i \leq \length{b} \And \All{k \in 0..(i-1)}{ a[k] = b[k]}\\
    \justification[\Implies]{$i \leq \length{b} \Implies i+1\leq \length{b}+1$ and $ a[i] \Ass b[i]$  }
    & a,b\in String \And 0 \leq i+1 \leq (\length{b}+1) \And \All{k \in 0..((i+1)-1)}{ a[k] = b[k]} \And a[i] \Ass b[i] 
\end{align*}


% Third implication should change

\subsubsection*{
    Third Implication
    $I\And i>\length{b} \Implies a,b \in String\And a=b  $
}
\begin{align*}
    &I\And i>\length{b}\\
    \justification{substitution of I }
    &a,b\in String \And 0 \leq i \leq (\length{b}+1) \And \All{k \in 0..(i-1)}{ a[k] \Ass b[k]} \And i > \length{b} \\
    \justification{ $i>\length{b}$and $i \leq (\length{b}+1)$ with some calculation}
    & a,b\in String \And \All{k \in 0..\length{b}}{ a[k] \Ass b[k]}\\
    \justification[\Implies]{Definition of two string equal}
    & a,b \in String \And a = b
\end{align*}

% a programe to write whether the string is equal to another string.
\subsection*{String Compare}
Missing part


\section{Task 1}
Since we have define some manipulation of String, we can see a 
string as a whole. So the input is an array of String. Hence we can define 
our precondiction as:
\begin{gather*}
    a\in String^*\And\length{a} = n
\end{gather*}
As the post condition as:
\begin{gather*}
    a,b \in String^* \And \length{b} \leq \length{a} \And \All{i\in 1..(\length{a}-1), a[i]\neq a[i+1],a[i-1] \neq a[i]\\}
    {\Exi{j \in 1..(\length{b}-1)}{a[i-1]= b[j-1], a[i]= b[j], a[i+1]= b[j+1], i\geq j}}\\
    \And \All {j \in 1..length(b)}{b[j]\neq b[j-1] \And b[j-1]\neq b[j+1]}
\end{gather*}
The postcondition mainly say all the adjust line is not the same string in array a , then 
the b array will contain those identical adjust three line and all the adjust line in the array b is not equal.
Hence the post condition is not
friendly there is a refinement for this postcondition that would be use in programme this uniq.\\
\subsection{Refinement of the postcondition }
By having this observation( proof)
\begin{align*}
    &b \in String^* \And j \in 0..(\length{b}-1) \All b[j] \neq b[j+1] \\
    \justification{sss}
\end{align*}
we can refine the post condition to this easier one. 
\begin{align*}
    &LOL
\end{align*}

\section{Task 2}
\section{Task 3}
\section{Task 4}



\end{document}